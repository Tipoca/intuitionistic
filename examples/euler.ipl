// This module implements the first problem from Project Euler
// (projecteuler.net).
//
// "If we list all the natural numbers below 10 that are multiples of
// 3 or 5, we get 3, 5, 6 and 9. The sum of these multiples is
// 23. Find the sum of all the multiples of 3 or 5 below 1000. Answer:
// 233168."

// First some useful abbreviations, the first of which should be a
// part of the initially opened module.
val fun (x bool) || (y bool) = x ? true : y;
val srem = mod32::srem;
val (+) = mod32::(+);
val (==) = mod32::(==);

val fun euler1(x i32) = purify i32 {
  new c = new_i32(0);
  for z in 0..x {
    if srem(z, 3, refl) == 0 || srem(z, 5, refl) == 0 {
      c := c + z;
    }
  }
  yield(get c);
};

// The the IPL interpreter check that the implementation is correct.
assert euler1(10) = 23 is i32;
assert euler1(1000) = 233168 is i32;

// We can also compile the euler() function to LLVM bytecode.
compile euler(x i32) i32 = block {
  new c = new_i32(0);
  for z in 0..x {
    if srem(z, 3, refl) == 0 || srem(z, 5, refl) == 0 {
      c := c + z;
    }
  }
  yield(get c);
};

// Alternatively, we could have reused the definition above, as
// follows.
//
// compile euler(x i32) i32 = block { yield(euler1(x)); };
//
//
// To use see the resulting bytecode, run
//
// $ ./iplc.opt euler.ipl euler.bc
//
// This gives a LLVM bytecode file euler.bc. The bytecode file can be
// disassembled using
//
// $ llvm-dis euler.bc
//
// This gives a text file 'euler.ll' containing the LLVM assembly
// listing for the euler() function. At the time of writing, the LLVM
// generated by iplc looks like this:
//
// define i32 @euler(i32 %x) {
// entry:
//   br label %begin
//
// begin:                                            ; preds = %merge, %entry
//   %local.0 = phi i32 [ 0, %entry ], [ %.local.0, %merge ]
//   %range = phi i32 [ 0, %entry ], [ %5, %merge ]
//   %0 = icmp ult i32 %range, %x
//   br i1 %0, label %loop, label %end
//
// loop:                                             ; preds = %begin
//   %1 = srem i32 %range, 3
//   %2 = icmp eq i32 %1, 0
//   br i1 %2, label %merge, label %false
//
// end:                                              ; preds = %begin
//   ret i32 %local.0
//
// false:                                            ; preds = %loop
//   %3 = srem i32 %range, 5
//   %4 = icmp eq i32 %3, 0
//   %phitmp = select i1 %4, i32 %range, i32 0
//   br label %merge
//
// merge:                                            ; preds = %false, %loop
//   %merge1 = phi i32 [ %phitmp, %false ], [ %range, %loop ]
//   %.local.0 = add i32 %merge1, %local.0
//   %5 = add i32 %range, 1
//   br label %begin
// }


// Finally, we can test the compiled function (as opposed to the
// interpreted function) using the IPL test syntax.
test euler(10) = 23;
test euler(1000) = 233168;

// These test will load the LLVM bytecode, execute it inside iplc, and
// verify that it gives the expected output.

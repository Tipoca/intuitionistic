// This whole file can be run through the type checker using the command
//
// $ ./iplc.opt tutorial.ipl.
//
// Many kinds of tests can be done at compile time: this can either be
// small unit test, or type assertions to assist the reader of the
// code.  There are two forms of assertions: type assertions and
// equality assertions.
//
// assert <expr> is <set>;
//
// assert <expr> = <expr> is <set>;
//
// In IPL, void is a first class type with exacly one value, denoted
// (). In this sense, the type 'void' is similar to Ocaml's 'unit' or
// Haskell's type '()'.

assert () is void;
assert () = () is void;

// Of course, void is not an empty type (as Haskell's Void). However,
// the use of word 'void' in this context is motivated by its use in
// C: also, one could argue that the type void is void of information,
// i.e., that an object of type void carries no information content.

// The type 'bool' is predefined, but if it wasn't predefined, it
// could have been defined as
//
// val bool = enum { false, true };
//
// Enum types are first class types, and their syntax is inspired by
// C.
assert bool = enum { false, true } is type;

// The order of the constants of an enum doesn't matter.
assert enum { true, false } = enum { false, true } is type;

// The constants of an enum are written with a quote,
assert 'foo is enum { foo, bar };
assert 'bar is enum { foo, bar };

// The constants true and false are predefined.
assert true = 'true is bool;
assert false = 'false is bool;

// The definition of a new value uses the syntax
//
// val <var> <type> = <val>;
//
// The type annotation is optional if <val> is monomorphic.
//
// val <var> = <val>;

// Define the empty type.
val empty = enum {};

// Functions are defined using the 'val fun' syntax.
val fun sample_function1(x empty, y bool) = y;

// Define the abort function.
val fun abort(t type) empty -> t = fun {};
// The fun {...} construction is explained below.

// Builtin type of unsigned 32-bit integers.
assert i32 is type;

// Define abbreviations for the usual arithmetic operators. The full
// list of built-in functions is in the file initial.ml.
val (+) = mod32::+;
val (-) = mod32::-;
val (-.) = mod32::(-.);
val (*) = mod32::*;
val xor = mod32::xor;
val ior = mod32::ior;
val and = mod32::and;
val lsl = mod32::lsl;
val lsr = mod32::lsr;
val asr = mod32::asr;
val (<) = mod32::<;
val (==) = mod32::==;

// Some tests of builtin arithmetic.
assert 9 = 3 + 3 + 3  is i32;
assert 0xffffffff = 0x0000ffff + 0xffff0000 is i32;
assert 0x00000000 = 0x00000001 + 0xffffffff is i32;
assert 0xffffffff = -1 is i32;
assert 6 = 2 * 3 is i32;
assert 6 = -2 * -3 is i32;
assert 0x0f0f0f0f = xor(0xffffffff, 0xf0f0f0f0) is i32;
assert 0xfffff0f0 = ior(0xffff0000, 0xf0f0f0f0) is i32;
assert 0xf0f00000 = and(0xffff0000, 0xf0f0f0f0) is i32;
assert lsl(1, 31c) = 0x80000000 is i32;
assert lsl(1, 32c) = 1 is i32;
assert lsl(2, 31c) = 0 is i32;
assert lsr(100, 0c) = 100 is i32;
assert lsr(0x80000000, 4c) = 0x08000000 is i32;
assert asr(0x80000000, 4c) = 0xf8000000 is i32;
assert lsr(4, 2c) = 1 is i32;

// A binary operation binop(t), on a type t, is a function from t
// times t to t.
val fun binop(t type) = tuple(_ t, _ t) -> t;
assert (+) is binop(i32);
assert (-) is binop(i32);

// A (decidable) binary relation binrel(t), on a set t, is a function
// from t times t to bool.
val fun binrel(t type) = tuple(_ t, _ t) -> bool;
assert (<) is binrel(i32);
assert (==) is binrel(i32);

// id is the polymorphic identity function.
val fun id(t type) t -> t = fun(x) x;

// For example:
assert id(bool) = fun(x) x is bool -> bool;

// This function is not equal to the identity function id(void).
assert fun(_) () is void -> void;

// The fun {...} construction is used to create a, possibly
// dependently typed, function defined on an enumerated set.  For
// example:
val dep_type bool -> type = fun { true: i32, false: i64 };
assert dep_type('true) = i32 is type;
assert dep_type('false) = i64 is type;
val dep_fun dep(x bool) -> dep_type(x) = fun {
  true: 100,
  false: 1000000000q
};
// Here dep(x A) -> B(x) is the dependent function type, and an
// integer literal ending with a q is a 64-bit literal.
assert dep_fun(true) = 100 is i32;
assert dep_fun(false) = 1000000000q is i64;

// Dependently typed functions work just like normal
// function. However, one difference is that non-dependent functions
// can be applied without having a known type, for example:
assert (fun(x) x + x)(1) = 2 is i32;
// This doesn't work for dependently typed functions. For example, the
// following assertion will give an error.
//
// assert fun { true: 100, false: 1000000000q }(true) = 100 is i32;

// Boolean negation is written as in C.
val fun !(x bool) = x ? false : true;
assert (!.) is bool -> bool;
// Complete specification!
assert !true = false is bool;
assert !false = true is bool;

// Boolean conjunction is written as in C.
val fun (x bool) && (y bool) = x ? y : false;
assert (&&) is binop(bool);
// Complete specification!
assert true && true = true is bool;
assert true && false = false is bool;
assert false && true = false is bool;
assert false && false = false is bool;
// First argument is evaluated first.
assert fun(x) true && x = id(bool) is  bool -> bool;
assert fun(x) false && x = fun(x) false is  bool -> bool;

// Boolean disjunction is written as in C.
val fun (x bool) || (y bool) = x ? true : y;
// Complete specification!
assert true || true = true is bool;
assert true || false = true is bool;
assert false || true = true is bool;
assert false || false = false is bool;
assert fun(x) false || x = fun(x) x is  bool -> bool;
assert fun(x) true || x = fun(x) true is bool -> bool;

val fun (x bool) ^^ (y bool) = x ? !y : y;
// Complete specification!
assert true ^^ true = false is bool;
assert true ^^ false = true is bool;
assert false ^^ true = true is bool;
assert false ^^ false = false is bool;
assert fun(x) false ^^ x = fun(x) x is bool -> bool;
assert fun(x) true ^^ x = fun(x) !x is bool -> bool;

// Syntax of structs.
val sample_struct1 = struct {};
val sample_struct2 = struct {a: bool };
val sample_struct3 = struct {a: bool, b: i32};

// A struct is simply a dependently typed function from an enumerated
// set.
assert struct {x: bool, y: i32} =
    dep(z enum {x, y}) -> fun { x: bool, y: i32}(z)
is type;

// Records.
val record1  sample_struct1 = fun {};
val record2  sample_struct2 = fun {a: true };
val record3  sample_struct3 = fun {a:true, b: 42};

// Record fields can be accessed using the following notation:
assert record3::a = true is bool;
assert record3::b = 42 is i32;

// However, record field extraction is simply application.
assert record2('a) = true is bool;

// A union is a dependently typed pair with an enumerated first
// component. For example:
val sample_union1 = union {};
val sample_union2 = union {a: bool};
val sample_union3 = union {a: bool, b: sample_struct3};

// The normal syntax for pairs can be used to create union objects.
assert ('a, true) is sample_union2;
assert ('b, fun { a:true, b:0 }) is sample_union3;

// However, the following notation is often more convenient:
assert a@true = ('a, true) is sample_union2;

// The fun {...} notation is extended to work on unions.
val sample_union_fun sample_union3 -> bool =
    fun { a@x: !x, b@y: y::a };

assert sample_union_fun(a@false) = true is bool;

// The type 'interface' is defined as union(x type, x -> type). The
// constant 'cmd' extracts the commands' of an interface.
assert cmd = fun(i) fst(i) is interface -> type;

// The constant 'res' extracts the type of responses to a command.
assert res = fun(i, x) snd(i)(x) is
    tuple(i interface, _ cmd(i)) -> type;
// Note the dependency in the type of res.

// Interfaces can be created using normal pair notatation. For
// example:
assert (i32, fun(_) void) is interface;
assert (bool, fun { true: i32, false: void }) is interface;

// The following notation is a convenient alternative:
assert meth(_ i32) void = (i32, fun(_) void) is interface;

// Two often useful interface:
val fun reader(A type) interface = meth(_ void) A;
val fun writer(A type) interface = meth(_ A) void;

// The meth {...} can be used to create interfaces where the set of
// commands is a union.
val systemX = meth {
  do_something: reader(bool),
  print_int: writer(i32)
};

// To understand how this works, it is important to first understand
// how to take the product of a family of interfaces.
val fun interface_prod(A type, F A -> interface) interface =
  meth(x A, y cmd(F(x))) res(F(x), y);

val systemX_cmd = enum { do_something, print_int };
val systemX_res systemX_cmd -> interface = fun {
  do_something: meth(x void) bool,
  print_int: meth(_ i32) void
};
assert systemX =
    interface_prod(systemX_cmd, systemX_res)
is interface;

// The 'call' syntax is used to create a procedure that invokes a
// command on an interface and returns its result.
assert call(10) is writer(i32) => void;
assert call() is reader(i32) => i32;
assert call(print_int@10) is systemX => void;

// Several calls can be combined into a block with the do notation.
assert block {
  do print_int.call(10);
  val x = do call(do_something@());
  if x {
    do print_int.call(100);
  }
} is systemX => void;

// A procedure can be "interpreted" using the interpret syntax.  For
// example, a fake systemX can be defined over the empty interface.
val fun fake_systemX(A type, prog systemX => A) meth {} => A = interpret prog {
  fun {
    do_something@_: block { yield(true); } ,
    print_int@_: block { }
  }
};

// When dealing with composite interfaces, the dot operation is often
// useful.
assert print_int.call(10) is systemX => void;
// The same notation can be used also in the case where the right hand
// side is a complex program instead of just call(10).

// The dot syntax can be generalised to the case when the left hand
// side is not an enum literal.
val fun dot(A type,
            F A -> interface,
            D type,
            a A,
            p F(a) => D)
    interface_prod(A, F) => D =
  interpret p { fun(x) call(a, x) }
;

// For example:
assert 'print_int is systemX_cmd;
assert fun(i) print_int.call(i) =
  fun(i) dot(systemX_cmd,
             systemX_res,
             void,
             'print_int,
             call(i))
is i32 -> systemX => void;


// A program over the interface writer(A) => void can be viewed as a
// sequence of A's. In particular, writer(i32) => void is a sequence
// of integers. IPL has a special notation for sequences of integers:
assert 10 .. 100 is writer(i32) => void;

// For loops are often used in conjuction with ranges.
val fun systemX_example(x i32) systemX => void = block {
  for y in 0 .. x {
    val ok = do call(do_something@());
    if ok {
      do call(print_int@y);
    }
    do call(print_int@0);
  }
};

// In addition their usefulness for generic programming with structs,
// unions, and interfaces, dependent types are also useful for
// expressing properties of objects. A popular example is division.
//
// First we introduce the following syntax:
val fun is_true(x bool) type = x eq(bool) true;
val fun is_false(x bool) type = x eq(bool) false;

// The special syntax "x eq(X) y" is used to express a special
// equality type.
assert refl is true eq(bool) true;
assert refl is false eq(bool) false;
// But not
// assert refl is true eq(bool) false;

// In IPL, division has the following type:
assert mod32::sdiv is tuple(_ i32, y i32, _ is_true(0 < y)) -> i32;
// That is, we only allow division with a positive dividend.
//
// Why not just require that is_false(0 == y) instead?
//
// Well, this works fine for unsigned integers, but for signed
// integers hardware often imposes the special restriction that
// division of MIN_INT by -1 is undefined. To avoid a fourth argument
// to sdiv, I instead restricted it to positive dividends.

// For example, we have
assert mod32::sdiv(10, 2, refl) = 5 is i32;
// But not
// assert mod32::sdiv(1, 0, refl) is i32;

// The following construct demonstrates that a boolean is either true
// or false.
val is_true_or_false
    dep(x bool) -> union { true: is_true(x), false: is_false(x) } = fun {
  true: true@refl,
  false: false@refl
};

// The following built-in axiom states that integer inequality is
// transitive.
val less_trans dep(
    x i32, y i32, z i32, _ is_true(x < y), _ is_true(y < z)) ->
  is_true(x < z) = mod32::less_trans;
assert less_trans(0, 1, 2, refl, refl) = refl is true eq(bool) true;

// Similarly, it is anti-symmetric.
val less_antisym dep(x i32) -> is_false(x < x) = mod32::less_antisym;
assert less_antisym(10) = refl is (10 < 10) eq(bool) false;

// The following built-in axiom states that if x == y returns true,
// then, in fact, x and y are equal in the propositional sense.
val eq_prop dep(x i32, y i32, z is_true(x == y)) -> x eq(i32) y = mod32::eq_prop;
assert eq_prop(5, 5, refl) = refl is 5 eq(i32) 5;

// This is the end of this tutorial. Please see the other example
// files for more IPL. Finally, please subscribe to
// https://groups.google.com/forum/#!forum/intuitionistic if you would
// like to keep abreast of the latest developments.
